/*数值的整数次方*/

/*
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
*/

/**
 * 1.全面考察指数的正负、底数是否为零等情况。
     1、base为0，exponent<0，无效的输入，
     2、指数为正，
     3、指数为负,
     4、指数为0四种情况即可
 * 2.写出指数的二进制表达，例如13表达为二进制1101。
 * 3.举例:10^1101 = 10^0001*10^0100*10^1000。
 * 4.通过&1和>>1来逐位读取1101，为1时将该位代表的乘数累乘到最终结果。
 */

/*
快速求幂算法
3 ^ 999
= 3 ^ (512 + 256 + 128 + 64 + 32 + 4 + 2 + 1)
= (3 ^ 512) * (3 ^ 256) * (3 ^ 128) * (3 ^ 64) * (3 ^ 32) * (3 ^ 4) * (3 ^ 2) * 3
999转为2进制数：1111100111，其各位就是要乘的数。
*/

/*
   问号表达式
 * <表达式1>?<表达式2>:<表达式3>
 * 在运算中，首先对第一个表达式进行检验，
 * 如果为真，则返回表达式2的值；
 * 如果为假，则返回表达式3的值。
 *
 * */

class Solution {
public:
    double Power(double base, int exponent) {
        long long p = abs((long long)exponent);
        double r = 1.0;
        while(p){
            if(p & 1) r *= base; // P & 1 等价于 (P % 2) == 1 求余
            base *= base;
            p >>= 1;
        }
        return exponent < 0 ? 1/ r : r;
    }
};
